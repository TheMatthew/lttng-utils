#!/usr/bin/python
#
# The MIT License (MIT)
#
# Copyright (C) 2012 - Francis Giraldeau <francis.giraldeau@gmail.com>
# Copyright (C) 2018 - Genevi√®ve Bastien <gbastien@versatic.net>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# given a command, trace the application with ust, kernel or both
# kernel tracing is enabled only if the user has appropriate rights
# the basename of the command will be used as the directory if none is provided

import argparse
import os
import sys
import re
import subprocess
import time
from os.path import join
import logging
import string
from subprocess import CalledProcessError
import shutil
import uuid
import signal
import yaml
import traceback

# the lttng command
LTTNG="lttng"

description="""Run command under tracing. If no kernel or ust option is provided,
then trace command under kernel, ust and both tracers enabled. The type of
the trace is indicated by appending a suffix to the trace output directory."""

dry_run = False
log_stream = sys.stdout
trace_running = True
current = ""
original_sigint = signal.getsignal(signal.SIGINT)

default_profile = "kernel"
evlist_search_path = [ os.path.join(os.getenv("PWD"), "profiles/"),
                       os.path.join(os.getenv("HOME"), ".lttng-utils/profiles/"),
                       "/usr/local/share/lttng-utils/profiles/",
                       "/usr/share/lttng-utils/profiles/" ]

def cmd_stub(cmds, check, cmd_env=None, with_shell=False):
    if cmd_env is None:
        cmd_env = os.environ
    logging.debug("LD_PRELOAD=" + cmd_env.get("LD_PRELOAD", ""))
    logging.debug("exec: " + " ".join(cmds))
    retcode = 0
    if (dry_run == False):
        retcode = subprocess.call(cmds, stdout=log_stream, stderr=log_stream, env=cmd_env)
        logging.debug("exit: " + str(retcode))
    if (check and retcode != 0):
        cmd_stub([LTTNG,"destroy", current], False)
        raise Exception("command failed")

def find_event_file(searchpath, name):
    for dir in searchpath:
        if dir is None:
            continue
        evfile = os.path.join(dir, name)
        if os.path.exists(evfile):
            return evfile
    return None

def merge_event_list(add_to, concat):
    for ev in concat:
        if not ev in add_to:
            add_to.append(ev)

def load_profiles(names):
    evLists = { "kernel": [], "ust": [] }
    for name in names:
        profile = load_profile(name)
        merge_event_list(evLists["kernel"], profile["kernel"])
        merge_event_list(evLists["ust"], profile["ust"])
    return evLists

def load_profile(name):
    evfile = name
    if (not os.path.exists(name)):
        evfile = find_event_file(evlist_search_path, name + ".profile")
    if (evfile is None):
        logging.warning("tracing profile " + name + " not found")
        return None
    profile = yaml.load(open(evfile))
    if "ust" not in profile:
        profile["ust"] = []
    if "kernel" not in profile:
        profile["kernel"] = []
    if "includes" in profile:
        # load and merge the included profiles
        subLists = load_profiles(profile["includes"])
        merge_event_list(profile["kernel"], subLists["kernel"])
        merge_event_list(profile["ust"], subLists["ust"])
    return profile

def get_profiles(searchpath):
    profiles = {}
    for dir in searchpath:
        if dir is None:
            continue
        for dirname, dirnames, filenames in os.walk(dir):
            for filename in filenames:
                if (filename.endswith(".profile")):
                    profile_name = re.sub('\.profile$', '', filename)
                    if profile_name not in profiles:
                        profile = yaml.load(open(dirname + filename))
                        if (profile is not None):
                            profiles[profile_name] = profile
    return profiles

def check_sessiond():
    retcode = subprocess.call([LTTNG, "list"], stdout=open(os.devnull, 'wb'), stderr=open(os.devnull, 'wb'))
    logging.debug("exit: " + str(retcode))
    if (retcode != 0):
        print("\x1b[1m\x1b[31mThe LTTNG session daemon is not running\x1b[0m")
        print("")
        print("It's preferable to run the session daemon as \x1b[1mroot\x1b[0m, as it is required to do \x1b[1mkernel tracing \x1b[0m, and for \x1b[1msome functionnalities of userspace tracing\x1b[0m. You can execute the following command:")
        print("")
        print("$ sudo systemctl start lttng-sessiond")
        print("")
        print("or")
        print("")
        print("$ sudo lttng-sessiond -d")
        print("")
        print("To trace \x1b[1monly userspace applications\x1b[0m, you can simply run")
        print("")
        print("$ lttng-sessiond -d")
        return False
    return True

def stop_running_trace(signum, frame):
    # Signal the tracing is to be stopped
    global trace_running
    trace_running = False

    # restore the original signal handler
    global original_sigint
    signal.signal(signal.SIGINT, original_sigint)

def wait_for_trace_interruption():
    global trace_running

    # Wait for ctrl-c to stop the trace
    signal.signal(signal.SIGINT, stop_running_trace)
    print("The trace is now recording, press ctrl+c to stop it")
    while trace_running:
        print(".", end='', flush=True)
        time.sleep(1)

def stop_tracing(current_session):
    cmd_stub([LTTNG,"stop"], False)
    cmd_stub([LTTNG,"destroy", current_session], False)
    logging.info("done tracing: " + current_session)

def do_trace(cmd, session, options, kernel, ust):
    if (not (kernel or ust)):
        return
    if (kernel):
        session += "-k"
    if (ust):
        session += "-u"
    out = join(options.output, session)
    # generate random uuid
    current = session + "-" + str(uuid.uuid4())

    logging.info("start tracing: " + current)

    # Step 1: start session
    try:
        cmd_stub([LTTNG, "create", current, "-o", out], True)
    except Exception as e:
        # if it fails, it may be stalled, try again, but make failure fatal
        cmd_stub([LTTNG, "destroy", current], False)
        cmd_stub([LTTNG, "create", current, "-o", out], True)

    # Step 2: enable required events
    add_context = False
    profile = load_profiles(options.selected_profile.split(","))
    if (kernel and profile["kernel"]):
        cmd_stub([LTTNG, "enable-channel", "k", "-k", "--subbuf-size", "16384", "--num-subbuf", "4096"], True)
        evlist = profile["kernel"]
        print("ev list: " + ", ".join(evlist))
        # enable pid/tid context if there is no sched_switch event
        if (options.enable_all_events):
            cmd_stub([LTTNG, "enable-event", "-c", "k", "-a", "-k"], True)
        else:
            if (not "sched_switch" in evlist or options.stateless):
                add_context = True
                cmd_stub([LTTNG, "add-context", "-k", "-c", "k", "-t", "pid", "-t", "tid", "-t", "procname"], True)
            if ("syscall" in evlist):
                evlist.remove("syscall")
                # do not check the return code, see http://bugs.lttng.org/issues/847
                cmd_stub([LTTNG, "enable-event", "-c", "k", "-a", "-k", "--syscall"], False)
            if profile["kernel"]:
                cmd_stub([LTTNG, "enable-event", "-k", "-c", "k", ",".join(evlist)], True)
    if (ust or profile["ust"]):
        if (options.enable_all_events):
            cmd_stub([LTTNG, "enable-event", "-c", "u", "-a", "-u"], True)
        else:
            if profile["ust"]:
                cmd_stub([LTTNG, "enable-event", "-u", "-c", "u", ",".join(profile["ust"])], True)
        # enable pid/tid context if there is no sched_switch event
        if not kernel or add_context:
            cmd_stub([LTTNG, "add-context", "-c", "u", "-u", "-t", "vpid", "-t", "vtid"], True)

    # Step 3: start tracing
    cmd_stub([LTTNG, "start"], True)

    # Step 4: run the program under tracing
    # Do not check the return value
    cmd_env = os.environ;
    if options.libc_wrapper:
        cmd_env = os.environ.copy()
        cmd_env["LD_PRELOAD"] = "liblttng-ust-libc-wrapper.so"

    # execute the command or wait for interruption
    if (cmd is not None):
        logging.info("Executing command: " + " ".join(cmd))
        cmd_stub(cmd, False, cmd_env)
    else:
        wait_for_trace_interruption()

    # Step 5: tear down
    stop_tracing(current)

if __name__=="__main__":
    # default directory for traces
    destdir = os.getenv("LTTNG_TRACE_HOME")
    if destdir is None:
        destdir = os.getcwd()

    parser = argparse.ArgumentParser(description=description)
    parser.add_argument("-k", "--kernel", dest="kernel", default=False, action="store_true", help="Trace only the kernel")
    parser.add_argument("-u", "--ust", dest="ust", default=False, action="store_true", help="Trace only user space")
    parser.add_argument("-o", "--output", dest="output", help="Output base directory for traces", metavar="DIR", default=destdir)
    parser.add_argument("-n", "--dry-run", dest="dry_run", default=False, action="store_true", help="Do not execute commands")
    parser.add_argument("-p", "--enable-profile", dest="selected_profile", default=default_profile, help="The tracing profile to use to get the events to trace. Can be a comma-separated list of profiles. Default: kernel")
    parser.add_argument("--list-profiles", dest="list_profiles", default=False, action="store_true", help="List event profiles")
    parser.add_argument("-a", "--all", dest="enable_all_events", default=False, action="store_true", help="Enable all events. This option has precedence over the selected profile")
    parser.add_argument("--enable-libc-wrapper", dest="libc_wrapper", default=False, action="store_true", help="Enable UST libc wrapper")
    parser.add_argument("--stateless", dest="stateless", default=False, action="store_true", help="Enable pid/tid/procname context for stateless trace processing")
    parser.add_argument("--name", dest="name", metavar="NAME", default=None, help="trace output name (default to command name with k/u suffix)")
    parser.add_argument('--verbose', '-v', action='count', dest="verbose", help="Verbose mode. The number of -v will increase verbosity of logging.")
    parser.add_argument('command', nargs=argparse.REMAINDER, help="The command to trace. It will be executed after the trace has started and the trace will terminate after its execution.")

    options = parser.parse_args()

    if (options.list_profiles):
        profiles = get_profiles(evlist_search_path)
        print("Available profiles:")
        print("")
        for p in profiles.keys():
            try:
                profile = profiles[p]
                desc = ""
                if "desc" in profile:
                    desc = profile["desc"]
                print('{:<7}{:<15}{:<25}'.format("", p, desc))
                if "includes" in profile:
                    print('{:<7}{:<15}{:<25}'.format("", "", "Includes profiles: " + ", ".join(profile["includes"])))
            except Exception as e:
                print("Error handling profile '" + p + "'")
        sys.exit(0)

    # try to create base directory if it doesn't exists
    if not os.path.exists(options.output):
        os.makedirs(options.output)

    # Consider that if no options for kernel or user space is provided
    # do the experiment by tracing kernel, ust and both
    if (not (options.kernel or options.ust)):
        options.kernel = True
        options.ust = True

    dry_run = options.dry_run
    fmt = '%(asctime)s %(levelname)s: %(message)s'
    log_level = {
        1: logging.WARNING,
        2: logging.INFO,
        3: logging.DEBUG
    }.get(options.verbose, logging.DEBUG)
    log_level = log_level if options.verbose else logging.ERROR
    log_level = logging.DEBUG if options.verbose else logging.INFO
    logging.basicConfig(level=log_level, format=fmt)

    if (dry_run == False):
        # Check that a session daemon is running
        if (check_sessiond() == False):
            sys.exit(1)

    logger = logging.getLogger()
    log_stream = logger.handlers[0].stream

    command = options.command
    target = {"name": "default", "cmd": None}
    if (command is not None and type(command) is list and len(command) > 0):
        target["name"] = os.path.basename(command[0])
        target["cmd"] = command
    # overide session name
    if (options.name is not None):
        target["name"] = options.name

    try:
        if (options.ust and options.kernel):
            do_trace(target["cmd"], target["name"], options, kernel=True, ust=True)
        elif (options.kernel):
            do_trace(target["cmd"], target["name"], options, kernel=True, ust=False)
        elif (options.ust):
            do_trace(target["cmd"], target["name"], options, kernel=False, ust=True)
    except Exception as e:
        logging.error(str(e))
        tb = traceback.format_exc()
        print(tb)
        cmd_stub([LTTNG,"destroy", "-a"], False)
    else:
        logging.debug("done")
