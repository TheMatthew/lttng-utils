#!/usr/bin/python
# given a command, trace the application with ust, kernel or both
# kernel tracing is enabled only if the user has appropriate rights
# the basename of the command will be used as the directory if none is provided

from optparse import OptionParser
import os
import sys
import re
import subprocess
import time
from os.path import join
import logging
import string
from subprocess import CalledProcessError
import shutil
import uuid
import signal

# the lttng command
LTTNG="lttng"

usage = """usage: %prog [options] -- [command]

Run command under tracing. If no kernel or ust option is provided,
then trace command under kernel, ust and both tracers enabled. The type of
the trace is indicated by appending a suffix to the trace output directory."""

dry_run = False
log_stream = sys.stdout
trace_running = True
current = ""
original_sigint = signal.getsignal(signal.SIGINT)

default_evlist = "default"
evlist_search_path = [ os.path.join(os.getenv("PWD"), "profiles/"),
                       os.path.join(os.getenv("HOME"), ".lttng-utils/profiles/"),
                       "/usr/local/share/lttng-utils/profiles/",
                       "/usr/share/lttng-utils/profiles/" ]

def cmd_stub(cmds, check, cmd_env=None, with_shell=False):
    if cmd_env is None:
        cmd_env = os.environ
    logging.debug("LD_PRELOAD=" + cmd_env.get("LD_PRELOAD", ""))
    logging.debug("exec: " + " ".join(cmds))
    retcode = 0
    if (dry_run == False):
        retcode = subprocess.call(cmds, stdout=log_stream, stderr=log_stream, env=cmd_env)
        logging.debug("exit: " + str(retcode))
    if (check and retcode != 0):
        cmd_stub([LTTNG,"destroy", current], False)
        raise Exception("command failed")

def find_event_file(searchpath, name):
    print(searchpath)
    for dir in searchpath:
        if dir is None:
            continue
        evfile = os.path.join(dir, name)
        if os.path.exists(evfile):
            return evfile
    return None

def load_event_list(name):
    evs = []
    evfile = name
    if (not os.path.exists(name)):
        evfile = find_event_file(evlist_search_path, name + ".list")
    if (evfile is None):
        logging.warning("event list " + name + " not found")
        return evs
    logging.info("using event list " + evfile)
    f = open(evfile)
    orig = f.readlines();
    for ev in orig:
        evs.append(ev.strip())
    return evs

def get_profiles(searchpath):
    profiles = {}
    for dir in searchpath:
        if dir is None:
            continue
        for dirname, dirnames, filenames in os.walk(dir):
            for filename in filenames:
                if (filename.endswith(".list")):
                    profile = re.sub('\.list$', '', filename)
                    if not profiles.has_key(profile):
                        profiles[profile] = dirname
    return profiles

def stop_running_trace(signum, frame):
    # Signal the tracing is to be stopped
    global trace_running
    trace_running = False

    # restore the original signal handler
    global original_sigint
    signal.signal(signal.SIGINT, original_sigint)

def wait_for_trace_interruption():
    global trace_running
    
    # Wait for ctrl-c to stop the trace
    signal.signal(signal.SIGINT, stop_running_trace)
    print("The trace is now recording, press ctrl+c to stop it")
    while trace_running:
        print(".", end='', flush=True)
        time.sleep(1)

def stop_tracing(current_session):
    cmd_stub([LTTNG,"stop"], False)
    cmd_stub([LTTNG,"destroy", current_session], False)
    logging.info("done tracing: " + current_session)

def do_trace(cmd, session, options, kernel, ust):
    if (not (kernel or ust)):
        return
    if (kernel):
        session += "-k"
    if (ust):
        session += "-u"
    out = join(options.output, session)
    # generate random uuid
    current = session + "-" + str(uuid.uuid4())

    logging.info("start tracing: " + current)  

    # Step 1: start session
    try:
        cmd_stub([LTTNG, "create", current, "-o", out], True)
    except Exception as e:
        # if it fails, it may be stalled, try again, but make failure fatal
        cmd_stub([LTTNG, "destroy", current], False)
        cmd_stub([LTTNG, "create", current, "-o", out], True)
    
    # Step 2: enable required events
    add_context = False
    if (kernel):
        cmd_stub([LTTNG, "enable-channel", "k", "-k", "--subbuf-size", "16384", "--num-subbuf", "4096"], True)
        evlist = load_event_list(options.evlist)
        # enable pid/tid context if there is no sched_switch event
        if (not "sched_switch" in evlist or options.stateless):
            add_context = True
            cmd_stub([LTTNG, "add-context", "-k", "-c", "k", "-t", "pid", "-t", "tid", "-t", "procname"], True)
        if (options.syscall):
            # do not check the return code, see http://bugs.lttng.org/issues/847
            cmd_stub([LTTNG, "enable-event", "-c", "k", "-a", "-k", "--syscall"], False)
        if (options.evlist is None or options.enable_all_events):
            cmd_stub([LTTNG, "enable-event", "-c", "k", "-a", "-k"], True)
        else:
            for ev in evlist:
                cmd_stub([LTTNG, "enable-event", "-k", "-c", "k", ev], True)
    if (ust):
        cmd_stub([LTTNG, "enable-channel", "u", "-u", "--subbuf-size", "4194304", "--num-subbuf", "64"], True)
        cmd_stub([LTTNG, "enable-event", "-c", "u", "-a", "-u"], True)
        if not kernel or add_context:
            cmd_stub([LTTNG, "add-context", "-c", "u", "-u", "-t", "vpid", "-t", "vtid"], True)
    
    # Step 3: start tracing
    cmd_stub([LTTNG, "start"], True)
    
    # Step 4: run the program under tracing
    # Do not check the return value
    cmd_env = os.environ;
    if options.libc_wrapper:
        cmd_env = os.environ.copy()
        cmd_env["LD_PRELOAD"] = "liblttng-ust-libc-wrapper.so"

    # execute the command or wait for interruption
    if (cmd is not None):
        logging.info("Executing command: " + " ".join(cmd))
        cmd_stub(cmd, False, cmd_env)
    else:
        wait_for_trace_interruption()
    
    # Step 5: tear down
    stop_tracing(current)

if __name__=="__main__":
    # default directory for traces
    destdir = os.getenv("LTTNG_TRACE_HOME")
    if destdir is None:
        destdir = os.getcwd()

    parser = OptionParser(usage=usage)
    parser.add_option("-k", "--kernel", dest="kernel", default=False, action="store_true", help="Trace only the kernel")
    parser.add_option("-u", "--ust", dest="ust", default=False, action="store_true", help="Trace only user space")
    parser.add_option("-o", "--output", dest="output", help="Output base directory for traces", metavar="DIR", default=destdir)
    parser.add_option("-n", "--dry-run", dest="dry_run", default=False, action="store_true", help="Do not execute commands")
    parser.add_option("-e", "--enable-event-list", dest="evlist", default=default_evlist, help="White list of events to enable")
    parser.add_option("--list-profiles", dest="list_profiles", default=False, action="store_true", help="List event profiles")
    parser.add_option("-a", "--all", dest="enable_all_events", default=False, action="store_true", help="Enable all events")
    parser.add_option("--enable-libc-wrapper", dest="libc_wrapper", default=False, action="store_true", help="Enable UST libc wrapper")
    parser.add_option("-s", "--syscall", dest="syscall", default=False, action="store_true", help="Enable syscall tracing")
    parser.add_option("--stateless", dest="stateless", default=False, action="store_true", help="Enable pid/tid/procname context for stateless trace processing")
    parser.add_option("--name", dest="name", metavar="NAME", default=None, help="trace output name (default to command name with k/u suffix)")
    parser.add_option("-v", "--verbose", dest="verbose", default=False, action="store_true", help="Verbose mode")

    (options, args) = parser.parse_args()

    if (options.list_profiles):
        profiles = get_profiles(evlist_search_path)
        print("Available profiles:")
        for p in profiles.keys():
            print(p)
        sys.exit(0)

    # try to create base directory if it doesn't exists
    if not os.path.exists(options.output):
        os.makedirs(options.output)

    # Consider that if no options for kernel or user space is provided
    # do the experiment by tracing kernel, ust and both
    if (not (options.kernel or options.ust)):
        options.kernel = True
        options.ust = True

    dry_run = options.dry_run
    fmt = '%(asctime)s %(levelname)s: %(message)s'
    log_level = logging.DEBUG if options.verbose else logging.INFO
    logging.basicConfig(level=log_level, format=fmt)

    logger = logging.getLogger()
    log_stream = logger.handlers[0].stream

    target = {"name": "default", "cmd": None}
    if (args is not None and type(args) is list and len(args) > 0):
        target["name"] = os.path.basename(args[0])
        target["cmd"] = args
    # overide session name
    if (options.name is not None):
        target["name"] = options.name

    try:
        if (options.ust and options.kernel):
            do_trace(target["cmd"], target["name"], options, kernel=True, ust=True)
        elif (options.kernel):
            do_trace(target["cmd"], target["name"], options, kernel=True, ust=False)
        elif (options.ust):
            do_trace(target["cmd"], target["name"], options, kernel=False, ust=True)
    except Exception as e:
        logging.error(str(e))
        cmd_stub([LTTNG,"destroy", "-a"], False)
    else:
        logging.debug("done")
